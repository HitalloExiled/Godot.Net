// <auto-generated/>
#if    !CANVAS_OCCLUSION_SHADER_GLES3_GLES
#define CANVAS_OCCLUSION_SHADER_GLES3_GLES

#nullable enable

using Godot.Net.Core.Math;
using Godot.Net.Drivers.GLES3;
using System.Runtime.CompilerServices;
using System;

namespace Godot.Net.Drivers.GLES3.Shaders
{
    using RealT = System.Single;

    public class CanvasOcclusionShaderGLES3 : ShaderGLES3
    {
        public enum Uniforms
        {
            PROJECTION,
            MODELVIEW1,
            MODELVIEW2,
            DIRECTION,
            Z_FAR,
        }

        public enum ShaderVariant
        {
            MODE_SDF,
            MODE_SHADOW,
            MODE_SHADOW_RGBA,
        }

        protected override void Init()
        {
            var uniformStrings = new string[]
            {
                "projection",
                "modelview1",
                "modelview2",
                "direction",
                "z_far",
            };

            var variantDefines = new string[]
            {
                "",
                "#define MODE_SHADOW",
                "#define MODE_SHADOW \n#define USE_RGBA_SHADOWS",
            };

            var texunitPairs = Array.Empty<TexUnitPair>();

            var uboPairs = Array.Empty<UBOPair>();

            var specPairs = Array.Empty<Specialization>();

            var feedbacks = Array.Empty<Feedback>();

            var vertexCode =
                """
                layout(location = 0) in vec3 vertex;
                uniform highp mat4 projection;
                uniform highp vec4 modelview1;
                uniform highp vec4 modelview2;
                uniform highp vec2 direction;
                uniform highp float z_far;
                #ifdef MODE_SHADOW
                out float depth;
                #endif
                void main() {
                    highp vec4 vtx = vec4(vertex, 1.0) * mat4(modelview1, modelview2, vec4(0.0, 0.0, 1.0, 0.0), vec4(0.0, 0.0, 0.0, 1.0));
                #ifdef MODE_SHADOW
                    depth = dot(direction, vtx.xy);
                #endif
                    gl_Position = projection * vtx;
                }
                """;

            var fragmentCode =
                """
                uniform highp mat4 projection;
                uniform highp vec4 modelview1;
                uniform highp vec4 modelview2;
                uniform highp vec2 direction;
                uniform highp float z_far;
                #ifdef MODE_SHADOW
                in highp float depth;
                #endif
                #ifdef USE_RGBA_SHADOWS
                layout(location = 0) out lowp vec4 out_buf;
                #else
                layout(location = 0) out highp float out_buf;
                #endif
                void main() {
                    float out_depth = 1.0;
                #ifdef MODE_SHADOW
                    out_depth = depth / z_far;
                #endif
                #ifdef USE_RGBA_SHADOWS
                    out_depth = clamp(out_depth, -1.0, 1.0);
                    out_depth = out_depth * 0.5 + 0.5;
                    highp vec4 comp = fract(out_depth * vec4(255.0 * 255.0 * 255.0, 255.0 * 255.0, 255.0, 1.0));
                    comp -= comp.xxyz * vec4(0.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);
                    out_buf = comp;
                #else
                    out_buf = out_depth;
                #endif
                }
                """;

            this.Setup(
                vertexCode,
                fragmentCode,
                "CanvasOcclusionShaderGLES3",
                uniformStrings,
                uboPairs,
                feedbacks,
                texunitPairs,
                specPairs,
                variantDefines
            );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public bool VersionBindShader(Guid version, ShaderVariant variant, ulong specialization = 0) =>
            base.VersionBindShader(version, (int)variant, specialization);

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public int VersionGetUniform(Uniforms uniform, Guid version, ShaderVariant variant, ulong specialization = 0) =>
            base.VersionGetUniform((int)uniform, version, (int)variant, specialization);

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public void VersionSetUniform(Uniforms uniform, byte value, Guid version, ShaderVariant variant, ulong specialization = 0)
        {
            if (this.VersionGetUniform(uniform, version, variant, specialization) < 0) return;
            GL.Singleton.Uniform1f(VersionGetUniform(uniform, version, variant, specialization), (float)value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public void VersionSetUniform(Uniforms uniform, double value, Guid version, ShaderVariant variant, ulong specialization = 0)
        {
            if (this.VersionGetUniform(uniform, version, variant, specialization) < 0) return;
            GL.Singleton.Uniform1f(VersionGetUniform(uniform, version, variant, specialization), (float)value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public void VersionSetUniform(Uniforms uniform, float value, Guid version, ShaderVariant variant, ulong specialization = 0)
        {
            if (this.VersionGetUniform(uniform, version, variant, specialization) < 0) return;
            GL.Singleton.Uniform1f(VersionGetUniform(uniform, version, variant, specialization), value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public void VersionSetUniform(Uniforms uniform, int value, Guid version, ShaderVariant variant, ulong specialization = 0)
        {
            if (this.VersionGetUniform(uniform, version, variant, specialization) < 0) return;
            GL.Singleton.Uniform1i(VersionGetUniform(uniform, version, variant, specialization), value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public void VersionSetUniform(Uniforms uniform, sbyte value, Guid version, ShaderVariant variant, ulong specialization = 0)
        {
            if (this.VersionGetUniform(uniform, version, variant, specialization) < 0) return;
            GL.Singleton.Uniform1i(VersionGetUniform(uniform, version, variant, specialization), (int)value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public void VersionSetUniform(Uniforms uniform, short value, Guid version, ShaderVariant variant, ulong specialization = 0)
        {
            if (this.VersionGetUniform(uniform, version, variant, specialization) < 0) return;
            GL.Singleton.Uniform1i(VersionGetUniform(uniform, version, variant, specialization), (int)value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public void VersionSetUniform(Uniforms uniform, uint value, Guid version, ShaderVariant variant, ulong specialization = 0)
        {
            if (this.VersionGetUniform(uniform, version, variant, specialization) < 0) return;
            GL.Singleton.Uniform1i(VersionGetUniform(uniform, version, variant, specialization), (int)value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
        public void VersionSetUniform(Uniforms uniform, ushort value, Guid version, ShaderVariant variant, ulong specialization = 0)
        {
            if (this.VersionGetUniform(uniform, version, variant, specialization) < 0) return;
            GL.Singleton.Uniform1ui(VersionGetUniform(uniform, version, variant, specialization), (uint)value);
        }

        public void VersionSetUniform(Uniforms uniform, in Color color, Guid version, ShaderVariant variant, ulong specialization = 0)
        {
            if (this.VersionGetUniform(uniform, version, variant, specialization) < 0) return;
            var col = new float[4] { color.R, color.G, color.B, color.A };
            GL.Singleton.Uniform4fv(VersionGetUniform(uniform, version, variant, specialization), 1, col);
        }

        public void VersionSetUniform(Uniforms uniform, in Vector2<RealT> vector, Guid version, ShaderVariant variant, ulong specialization = 0)
        {
            if (this.VersionGetUniform(uniform, version, variant, specialization) < 0) return;
            var vec2 = new float[2] { vector.X, vector.Y };
            GL.Singleton.Uniform2fv(VersionGetUniform(uniform, version, variant, specialization), 1, vec2);
        }

        public void VersionSetUniform(Uniforms uniform, in Vector2<int> vector, Guid version, ShaderVariant variant, ulong specialization = 0)
        {
            if (this.VersionGetUniform(uniform, version, variant, specialization) < 0) return;
            var vec2 = new int[2] { vector.X, vector.Y };
            GL.Singleton.Uniform2iv(VersionGetUniform(uniform, version, variant, specialization), 1, vec2);
        }

        public void VersionSetUniform(Uniforms uniform, in Vector3<RealT> vector, Guid version, ShaderVariant variant, ulong specialization = 0)
        {
            if (this.VersionGetUniform(uniform, version, variant, specialization) < 0) return;
            var vec3 = new float[3] { vector.X, vector.Y, vector.Z };
            GL.Singleton.Uniform3fv(VersionGetUniform(uniform, version, variant, specialization), 1, vec3);
        }

        public void VersionSetUniform(Uniforms uniform, float a, float b, Guid version, ShaderVariant variant, ulong specialization = 0)
        {
            if (this.VersionGetUniform(uniform, version, variant, specialization) < 0) return;
            GL.Singleton.Uniform2f(VersionGetUniform(uniform, version, variant, specialization), a, b);
        }

        public void VersionSetUniform(Uniforms uniform, float a, float b, float c, Guid version, ShaderVariant variant, ulong specialization = 0)
        {
            if (this.VersionGetUniform(uniform, version, variant, specialization) < 0) return;
            GL.Singleton.Uniform3f(VersionGetUniform(uniform, version, variant, specialization), a, b, c);
        }

        public void VersionSetUniform(Uniforms uniform, float a, float b, float c, float d, Guid version, ShaderVariant variant, ulong specialization = 0)
        {
            if (this.VersionGetUniform(uniform, version, variant, specialization) < 0) return;
            GL.Singleton.Uniform4f(VersionGetUniform(uniform, version, variant, specialization), a, b, c, d);
        }

        public void VersionSetUniform(Uniforms uniform, Transform3D<RealT> transform, Guid version, ShaderVariant variant, ulong specialization = 0)
        {
            if (this.VersionGetUniform(uniform, version, variant, specialization) < 0) return;
            var matrix = new float[16]
            {
                /* build a 16x16 matrix */
                transform.Basis[0, 0],
                transform.Basis[1, 0],
                transform.Basis[2, 0],
                0,
                transform.Basis[0, 1],
                transform.Basis[1, 1],
                transform.Basis[2, 1],
                0,
                transform.Basis[0, 2],
                transform.Basis[1, 2],
                transform.Basis[2, 2],
                0f,
                transform.Origin.X,
                transform.Origin.Y,
                transform.Origin.Z,
                1f
            };

            GL.Singleton.UniformMatrix4fv(VersionGetUniform(uniform, version, variant, specialization), 1, false, matrix);
        }

        public void VersionSetUniform(Uniforms uniform, in Transform2D<RealT> transform, Guid version, ShaderVariant variant, ulong specialization = 0)
        {
            if (this.VersionGetUniform(uniform, version, variant, specialization) < 0) return;
            var matrix = new float[16]
            {
                /* build a 16x16 matrix */
                transform[0, 0],
                transform[0, 1],
                0f,
                0f,
                transform[1, 0],
                transform[1, 1],
                0f,
                0f,
                0f,
                0f,
                1f,
                0f,
                transform[2, 0],
                transform[2, 1],
                0f,
                1f
            };

            GL.Singleton.UniformMatrix4fv(this.VersionGetUniform(uniform, version, variant, specialization), 1, false, matrix);
        }

        public void VersionSetUniform(Uniforms uniform, in Projection<RealT> projection, Guid version, ShaderVariant variant, ulong specialization = 0)
        {
            if (this.VersionGetUniform(uniform, version, variant, specialization) < 0) return;
            var matrix = new float[16];
            for (int i = 0; i < 4; i++)
            {
                for (int j = 0; j < 4; j++)
                {
                    matrix[i * 4 + j] = projection[i, j];
                }

            }

            GL.Singleton.UniformMatrix4fv(VersionGetUniform(uniform, version, variant, specialization), 1, false, matrix);
        }
    }
}

#endif
