namespace Godot.Net.SourceGenerators;

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;

[Generator]
public class ShaderGenerator : ISourceGenerator
{
    private static string CastIf(string type, string expectedType) => type != expectedType ? $"({expectedType})" : "";

    private static string GenerateGLES3(AdditionalText file, Dictionary<string, AdditionalText> files, string @namespace, string className, string classSuffix)
    {
        var ast  = ParseGLES3(file, files);
        var code = new CodeWriter();

        var defvariant    = "";
        var defspec       = 0;
        var baseClassName = $"Shader{classSuffix}";

        #region helpers
        void makeInline() => code!.WriteLine("[MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        void makeCheck()  => code!.WriteLine("if (this.VersionGetUniform(uniform, version, variant, specialization) < 0) return;");
        void makeCheckedBlock(params string[] lines)
        {
            openBlock();
                makeCheck();

                foreach (var line in lines)
                {
                    code.WriteLine(line);
                }

            closeBlock();
            code.NewLine();
        }

        void openBlock()
        {
            code!.WriteLine("{");
            code.Indent();
        }

        void closeBlock(bool semicolon = false)
        {
            code!.Deindent();
            if (semicolon)
            {
                code.WriteLine("};");
            }
            else
            {
                code.WriteLine("}");
            }
        }
        #endregion helpers

        code.WriteLine("// <auto-generated/>");
        code.WriteLine($"#if    !{ToSnakeCase(className)}_GLES");
        code.WriteLine($"#define {ToSnakeCase(className)}_GLES");

        code.NewLine();

        code.WriteLine("#nullable enable");

        code.NewLine();

        code.WriteLine("using Godot.Net.Core.Math;");
        code.WriteLine("using Godot.Net.Drivers.GLES3;");
        code.WriteLine("using System.Runtime.CompilerServices;");
        code.WriteLine("using System;");

        code.NewLine();

        code.WriteLine($"namespace {@namespace}");
        #region namespace declaration
        openBlock();

        code.WriteLine("using RealT = System.Single;");
        code.NewLine();

        #region class declaration
        code.WriteLine($"public class {className} : {baseClassName}");

        openBlock();

        #region public enums
        if (ast.Uniforms.Any())
        {
            code.WriteLine("public enum Uniforms");
            openBlock();

            foreach (var x in ast.Uniforms)
            {
                code.WriteLine(x.ToUpper() + ",");
            }

            closeBlock();
            code.NewLine();
        }

        if (ast.VariantNames.Any())
        {
            code.WriteLine("public enum ShaderVariant");
            openBlock();

            foreach (var x in ast.VariantNames)
            {
                code.WriteLine(x + ",");
            }

            closeBlock();
            code.NewLine();
        }
        else
        {
            code.WriteLine("public enum ShaderVariant { DEFAULT }");
            defvariant = " = ShaderVariant.DEFAULT";
        }

        if (ast.SpecializationNames.Any())
        {
            code.WriteLine("public enum Specializations");
            openBlock();

            var counter = 0;

            foreach (var x in ast.SpecializationNames)
            {
                code.WriteLine(x.ToUpper() + " = " + (1 << counter) + ",");
                counter += 1;
            }

            closeBlock();
            code.NewLine();
        }
        #endregion public enums

        for (var i = 0; i < ast.SpecializationNames.Count; i++)
        {
            var defval = ast.SpecializationValues[i].Trim();
            if (defval.ToUpper() == "TRUE" || defval == "1")
            {
                defspec |= 1 << i;
            }
        }

        #region protected override void Init
        code.WriteLine("protected override void Init()");

        openBlock();

        if (ast.Uniforms.Any())
        {
            code.WriteLine("var uniformStrings = new string[]");
            openBlock();

            foreach (var x in ast.Uniforms)
            {
                code.WriteLine("\"" + x + "\",");
            }

            closeBlock(true); // uniformStrings
            code.NewLine();
        }
        else
        {
            code.WriteLine("var uniformStrings = Array.Empty<string>();");
            code.NewLine();
        }

        if (ast.VariantDefines.Any())
        {
            code.WriteLine("var variantDefines = new string[]");
            openBlock();

            foreach (var x in ast.VariantDefines)
            {
                code.WriteLine("\"" + x + "\",");
            }

            closeBlock(true); // variantDefines
            code.NewLine();
        }
        else
        {
            code.WriteLine("var variantDefines = new string[] { \" \" };");
            code.NewLine();
        }

        if (ast.Texunits.Any())
        {
            code.WriteLine("var texunitPairs = new TexUnitPair[]");
            openBlock();

            foreach (var x in ast.Texunits)
            {
                code.WriteLine("{\"" + x[0] + "\"," + x[1] + "},");
            }

            closeBlock(true); // texunitPairs
            code.NewLine();
        }
        else
        {
            code.WriteLine("var texunitPairs = Array.Empty<TexUnitPair>();");
            code.NewLine();
        }

        if (ast.Ubos.Any())
        {
            code.WriteLine("var uboPairs = new UBOPair[]");
            openBlock();

            foreach (var x in ast.Ubos)
            {
                code.WriteLine("{\"" + x[0] + "\"," + x[1] + "},");
            }

            closeBlock(true); // uboPairs
            code.NewLine();
        }
        else
        {
            code.WriteLine("var uboPairs = Array.Empty<UBOPair>();");
            code.NewLine();
        }

        var specializationsFound = new List<string>();

        if (ast.SpecializationNames.Any())
        {
            code.WriteLine("var specPairs = new Specialization[]");
            openBlock();

            for (var i = 0; i < ast.SpecializationNames.Count; i++)
            {
                var defval = ast.SpecializationValues[i].Trim();
                defval = defval.ToUpper() == "TRUE" || defval == "1" ? "true" : "false";

                code.WriteLine("new(\"" + ast.SpecializationNames[i] + "\", " + defval + "),");

                specializationsFound.Add(ast.SpecializationNames[i]);
            }

            closeBlock(true); // specPairs
            code.NewLine();
        }
        else
        {
            code.WriteLine("var specPairs = Array.Empty<Specialization>();");
            code.NewLine();
        }

        var feedbackCount = 0;

        if (ast.Feedbacks.Any())
        {
            code.WriteLine("var feedbacks = new Feedback[]");
            openBlock();

            foreach (var (name, spec) in ast.Feedbacks)
            {
                if (specializationsFound.Contains(spec))
                {
                    code.WriteLine("{\"" + name + "\"," + (1 << specializationsFound.IndexOf(spec)) + "},");
                }
                else
                {
                    code.WriteLine("{\"" + name + "\",0},");
                }

                feedbackCount += 1;
            }

            closeBlock(true); // feedbacks
            code.NewLine();
        }
        else
        {
            code.WriteLine("var feedbacks = Array.Empty<Feedback>();");
            code.NewLine();
        }

        code.WriteLine("var vertexCode =");
        code.Indent();
        code.WriteLine("\"\"\"");

        foreach (var line in ast.VertexLines)
        {
            code.WriteLine(line);
        }

        code.WriteLine("\"\"\";");
        code.Deindent();
        code.NewLine();

        code.WriteLine("var fragmentCode =");
        code.Indent();
        code.WriteLine("\"\"\"");

        foreach (var line in ast.FragmentLines)
        {
            code.WriteLine(line);
        }

        code.WriteLine("\"\"\";");
        code.Deindent();
        code.NewLine();

        code.WriteLine("this.Setup(");
        code.Indent();
            code.WriteLine("vertexCode,");
            code.WriteLine("fragmentCode,");
            code.WriteLine($"\"{className}\",");
            code.WriteLine("uniformStrings,");
            code.WriteLine("uboPairs,");
            code.WriteLine("feedbacks,");
            code.WriteLine("texunitPairs,");
            code.WriteLine("specPairs,");
            code.WriteLine("variantDefines");
        code.Deindent();
        code.WriteLine(");");

        closeBlock();
        code.NewLine();

        #endregion protected override void Init

        makeInline();
        code.WriteLine($"public bool VersionBindShader(Guid version, ShaderVariant variant{defvariant}, ulong specialization = {defspec}) =>");
        code.WriteIdentedLine("base.VersionBindShader(version, (int)variant, specialization);");

        code.NewLine();

        if (ast.Uniforms.Any())
        {
            #region VersionSetUniform overloads
            void makeVersionSetUniformCallUniform1f(string valueType)
            {
                makeInline();
                code.WriteLine($"public void VersionSetUniform(Uniforms uniform, {valueType} value, Guid version, ShaderVariant variant{defvariant}, ulong specialization = {defspec})");
                makeCheckedBlock($"GL.Singleton.Uniform1f(VersionGetUniform(uniform, version, variant, specialization), {CastIf(valueType, "float")}value);");
            }

            void makeVersionSetUniformCallUniform1i(string valueType)
            {
                makeInline();
                code!.WriteLine($"public void VersionSetUniform(Uniforms uniform, {valueType} value, Guid version, ShaderVariant variant{defvariant}, ulong specialization = {defspec})");
                makeCheckedBlock($"GL.Singleton.Uniform1i(VersionGetUniform(uniform, version, variant, specialization), {CastIf(valueType, "int")}value);");
            }

            void makeVersionSetUniformCallUniform1ui(string valueType)
            {
                makeInline();
                code!.WriteLine($"public void VersionSetUniform(Uniforms uniform, {valueType} value, Guid version, ShaderVariant variant{defvariant}, ulong specialization = {defspec})");
                makeCheckedBlock($"GL.Singleton.Uniform1ui(VersionGetUniform(uniform, version, variant, specialization), {CastIf(valueType, "uint")}value);");
            }

            makeInline();
            code.WriteLine($"public int VersionGetUniform(Uniforms uniform, Guid version, ShaderVariant variant{defvariant}, ulong specialization = {defspec}) =>");
            code.WriteIdentedLine("base.VersionGetUniform((int)uniform, version, (int)variant, specialization);");

            code.NewLine();

            makeVersionSetUniformCallUniform1f("byte");
            makeVersionSetUniformCallUniform1f("double");
            makeVersionSetUniformCallUniform1f("float");
            makeVersionSetUniformCallUniform1i("int");
            makeVersionSetUniformCallUniform1i("sbyte");
            makeVersionSetUniformCallUniform1i("short");
            makeVersionSetUniformCallUniform1i("uint");
            makeVersionSetUniformCallUniform1ui("ushort");

            code.WriteLine($"public void VersionSetUniform(Uniforms uniform, in Color color, Guid version, ShaderVariant variant{defvariant}, ulong specialization = {defspec})");
            makeCheckedBlock(
                "var col = new float[4] { color.R, color.G, color.B, color.A };",
                "GL.Singleton.Uniform4fv(VersionGetUniform(uniform, version, variant, specialization), 1, col);"
            );

            code.WriteLine($"public void VersionSetUniform(Uniforms uniform, in Vector2<RealT> vector, Guid version, ShaderVariant variant{defvariant}, ulong specialization = {defspec})");
            makeCheckedBlock(
                "var vec2 = new float[2] { vector.X, vector.Y };",
                "GL.Singleton.Uniform2fv(VersionGetUniform(uniform, version, variant, specialization), 1, vec2);"
            );

            code.WriteLine($"public void VersionSetUniform(Uniforms uniform, in Vector2<int> vector, Guid version, ShaderVariant variant{defvariant}, ulong specialization = {defspec})");
            makeCheckedBlock(
                "var vec2 = new int[2] { vector.X, vector.Y };",
                "GL.Singleton.Uniform2iv(VersionGetUniform(uniform, version, variant, specialization), 1, vec2);"
            );

            code.WriteLine($"public void VersionSetUniform(Uniforms uniform, in Vector3<RealT> vector, Guid version, ShaderVariant variant{defvariant}, ulong specialization = {defspec})");
            makeCheckedBlock(
                "var vec3 = new float[3] { vector.X, vector.Y, vector.Z };",
                "GL.Singleton.Uniform3fv(VersionGetUniform(uniform, version, variant, specialization), 1, vec3);"
            );

            code.WriteLine($"public void VersionSetUniform(Uniforms uniform, float a, float b, Guid version, ShaderVariant variant{defvariant}, ulong specialization = {defspec})");
            makeCheckedBlock("GL.Singleton.Uniform2f(VersionGetUniform(uniform, version, variant, specialization), a, b);");

            code.WriteLine($"public void VersionSetUniform(Uniforms uniform, float a, float b, float c, Guid version, ShaderVariant variant{defvariant}, ulong specialization = {defspec})");
            makeCheckedBlock("GL.Singleton.Uniform3f(VersionGetUniform(uniform, version, variant, specialization), a, b, c);");

            code.WriteLine($"public void VersionSetUniform(Uniforms uniform, float a, float b, float c, float d, Guid version, ShaderVariant variant{defvariant}, ulong specialization = {defspec})");
            makeCheckedBlock("GL.Singleton.Uniform4f(VersionGetUniform(uniform, version, variant, specialization), a, b, c, d);");

            code.WriteLine($"public void VersionSetUniform(Uniforms uniform, Transform3D<RealT> transform, Guid version, ShaderVariant variant{defvariant}, ulong specialization = {defspec})");
            openBlock();
                makeCheck();
                code.WriteLine("var matrix = new float[16]");
                openBlock();
                    code.WriteLine("/* build a 16x16 matrix */");
                    code.WriteLine("transform.Basis[0, 0],");
                    code.WriteLine("transform.Basis[1, 0],");
                    code.WriteLine("transform.Basis[2, 0],");
                    code.WriteLine("0,");
                    code.WriteLine("transform.Basis[0, 1],");
                    code.WriteLine("transform.Basis[1, 1],");
                    code.WriteLine("transform.Basis[2, 1],");
                    code.WriteLine("0,");
                    code.WriteLine("transform.Basis[0, 2],");
                    code.WriteLine("transform.Basis[1, 2],");
                    code.WriteLine("transform.Basis[2, 2],");
                    code.WriteLine("0f,");
                    code.WriteLine("transform.Origin.X,");
                    code.WriteLine("transform.Origin.Y,");
                    code.WriteLine("transform.Origin.Z,");
                    code.WriteLine("1f");
                closeBlock(true);
                code.NewLine();
                code.WriteLine("GL.Singleton.UniformMatrix4fv(VersionGetUniform(uniform, version, variant, specialization), 1, false, matrix);");
            closeBlock();
            code.NewLine();

            code.WriteLine($"public void VersionSetUniform(Uniforms uniform, in Transform2D<RealT> transform, Guid version, ShaderVariant variant{defvariant}, ulong specialization = {defspec})");
            openBlock();
                makeCheck();
                code.WriteLine("var matrix = new float[16]");
                openBlock();
                    code.WriteLine("/* build a 16x16 matrix */");
                    code.WriteLine("transform[0, 0],");
                    code.WriteLine("transform[0, 1],");
                    code.WriteLine("0f,");
                    code.WriteLine("0f,");
                    code.WriteLine("transform[1, 0],");
                    code.WriteLine("transform[1, 1],");
                    code.WriteLine("0f,");
                    code.WriteLine("0f,");
                    code.WriteLine("0f,");
                    code.WriteLine("0f,");
                    code.WriteLine("1f,");
                    code.WriteLine("0f,");
                    code.WriteLine("transform[2, 0],");
                    code.WriteLine("transform[2, 1],");
                    code.WriteLine("0f,");
                    code.WriteLine("1f");
                closeBlock(true);
                code.NewLine();
                code.WriteLine("GL.Singleton.UniformMatrix4fv(this.VersionGetUniform(uniform, version, variant, specialization), 1, false, matrix);");

            closeBlock();
            code.NewLine();

            code.WriteLine($"public void VersionSetUniform(Uniforms uniform, in Projection<RealT> projection, Guid version, ShaderVariant variant{defvariant}, ulong specialization = {defspec})");
            openBlock();
                makeCheck();
                code.WriteLine("var matrix = new float[16];");
                code.WriteLine("for (int i = 0; i < 4; i++)");
                openBlock();
                    code.WriteLine("for (int j = 0; j < 4; j++)");
                    openBlock();
                        code.WriteLine("matrix[i * 4 + j] = projection[i, j];");
                    closeBlock();
                    code.NewLine();
                closeBlock();
                code.NewLine();
                code.WriteLine("GL.Singleton.UniformMatrix4fv(VersionGetUniform(uniform, version, variant, specialization), 1, false, matrix);");
            closeBlock();
            #endregion VersionSetUniform overloads
        }

        closeBlock();
        #endregion class declaration
        closeBlock();
        #endregion namespace declaration

        code.NewLine();

        code.WriteLine("#endif");

        return code.Source;
    }

    private static string GenerateRaw(AdditionalText file, Dictionary<string, AdditionalText> files, string className) => throw new NotImplementedException();
    private static string GenerateRDGLES(AdditionalText file, Dictionary<string, AdditionalText> files, string usingNamespace, string className, string type) => throw new NotImplementedException();

    private static GLES3Ast ParseGLES3(AdditionalText file, Dictionary<string, AdditionalText> files)
    {
        var ast = new GLES3Ast();

        ParseGLES3(file, files, ast, 0);

        return ast;
    }

    private static void ParseGLES3(AdditionalText file, Dictionary<string, AdditionalText> files, GLES3Ast ast, int depth)
    {
        var enumerator = file.GetText()!.Lines.GetEnumerator();

        string? readline() => enumerator.MoveNext() ? enumerator.Current.ToString() : null;

        var line = readline();

        while (line != null)
        {
            if (line.IndexOf("=") != -1 && ast.Reading == "")
            {
                // Mode
                var eqpos   = line.IndexOf("=");
                var defname = line.Substring(0, eqpos).Trim().ToUpper();
                var define  = line.Substring(eqpos + 1).Trim();

                ast.VariantNames.Add(defname);
                ast.VariantDefines.Add(define);

                line             = readline();
                ast.LineOffset  += 1;
                ast.VertexOffset = ast.LineOffset;
                continue;
            }

            if (line.IndexOf("=") != -1 && ast.Reading == "specializations")
            {
                // Specialization
                var eqpos     = line.IndexOf("=");
                var specname  = line.Substring(0, eqpos).Trim();
                var specvalue = line.Substring(eqpos + 1);

                ast.SpecializationNames.Add(specname);
                ast.SpecializationValues.Add(specvalue);

                line = readline();

                ast.LineOffset += 1;
                ast.VertexOffset = ast.LineOffset;
                continue;
            }

            if (line.IndexOf("#[modes]") != -1)
            {
                // Nothing really, just skip
                line             = readline();
                ast.LineOffset  += 1;
                ast.VertexOffset = ast.LineOffset;
                continue;
            }

            if (line.IndexOf("#[specializations]") != -1)
            {
                ast.Reading      = "specializations";
                line             = readline();
                ast.LineOffset  += 1;
                ast.VertexOffset = ast.LineOffset;
                continue;
            }

            if (line.IndexOf("#[vertex]") != -1)
            {
                ast.Reading = "vertex";
                line              = readline();
                ast.LineOffset  += 1;
                ast.VertexOffset = ast.LineOffset;
                continue;
            }

            if (line.IndexOf("#[fragment]") != -1)
            {
                ast.Reading        = "fragment";
                line               = readline();
                ast.LineOffset    += 1;
                ast.FragmentOffset = ast.LineOffset;
                continue;
            }

            while (line!.IndexOf("#include ") != -1)
            {
                var replacedLine = line.Replace("#include ", "").Trim();
                var includeline = replacedLine.Substring(1, replacedLine.Length - 2);

                var includedFile = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(file.Path), includeline));
                if (!ast.VertexIncludedFiles.Contains(includedFile) && ast.Reading == "vertex")
                {
                    if (files.TryGetValue(includedFile, out var includedFileAdditionalText))
                    {
                        ast.VertexIncludedFiles.Add(includedFile);
                        ParseGLES3(includedFileAdditionalText, files, ast, depth + 1);
                    }
                    else
                    {
                        Console.WriteLine($"Error in file '{file.Path}': #include {includeline} resolved to {includedFile} could not be found!");
                    }
                }
                else if (!ast.FragmentIncludedFiles.Contains(includedFile) && ast.Reading == "fragment")
                {
                    if (files.TryGetValue(includedFile, out var includedFileAdditionalText))
                    {
                        ast.FragmentIncludedFiles.Add(includedFile);
                        ParseGLES3(includedFileAdditionalText, files, ast, depth + 1);
                    }
                    else
                    {
                        Console.WriteLine($"Error in file '{file.Path}': #include {includeline} resolved to {includedFile} could not be found!");
                    }
                }

                line = readline();
            }

            if (line.IndexOf("uniform") != -1 && line.ToLower().IndexOf("texunit:") != -1)
            {
                // texture unit
                var texunitstr = line.Substring(line.IndexOf(":") + 1).Trim();
                var texunit = texunitstr == "auto" ? "-1" : int.Parse(texunitstr).ToString();
                var uline = line.Substring(0, line.ToLower().IndexOf("//"));
                uline = uline.Replace("uniform", "");
                uline = uline.Replace("highp", "");
                uline = uline.Replace(";", "");

                var lines = uline.Split(',');
                foreach (var x_ in lines)
                {
                    var x = x_.Trim();

                    x = x.Substring(x.LastIndexOf(" ") + 1);

                    if (x.IndexOf('[') != -1)
                    {
                        // unfiorm array
                        x = x.Substring(0, x.IndexOf('['));
                    }

                    if (ast.TexunitNames.Contains(x))
                    {
                        ast.Texunits.Add(x);
                        ast.Texunits.Add(texunit);
                        ast.TexunitNames.Add(x);
                    }
                }
            }
            else if (line.IndexOf("uniform") != -1 && line.ToLower().IndexOf("ubo:") != -1)
            {
                // uniform buffer object
                var ubostr = line.Substring(line.IndexOf(":") + 1).Trim();
                var ubo    = int.Parse(ubostr).ToString();

                var uline = line.Substring(0, line.ToLower().IndexOf("//"));
                uline = uline.Substring(uline.IndexOf("uniform") + "uniform".Length);
                uline = uline.Replace("highp", "");
                uline = uline.Replace(";", "");
                uline = uline.Replace("{", "").Trim();

                var lines = uline.Split(',');
                foreach (var x_ in lines)
                {
                    var x = x_.Trim();
                    x = x.Substring(x.LastIndexOf(" ") + 1);
                    if (x.IndexOf("[") != -1)
                    {
                        // unfiorm array
                        x = x.Substring(0, x.IndexOf("["));
                    }

                    if (ast.UboNames.Contains(x))
                    {
                        ast.Ubos.Add(x);
                        ast.Ubos.Add(ubo);
                        ast.UboNames.Add(x);
                    }
                }
            }

            else if (line.IndexOf("uniform") != -1 && line.IndexOf("{") == -1 && line.IndexOf(";") != -1)
            {
                var uline = line.Replace("uniform", "").Replace(";", "");

                var lines = uline.Split(',');
                foreach (var x_ in lines)
                {
                    var x = x_.Trim();
                    x = x.Substring(x.LastIndexOf(" ") + 1);
                    if (x.IndexOf("[") != -1)
                    {
                        // unfiorm array
                        x = x.Substring(0, x.IndexOf("["));
                    }
                    if (!ast.Uniforms.Contains(x))
                    {
                        ast.Uniforms.Add(x);
                    }
                }
            }

            if ((line.Trim().IndexOf("out ") == 0 || line.Trim().IndexOf("flat ") == 0) && line.IndexOf("tfb:") != -1)
            {
                var uline = line.Replace("flat ", "");
                uline = uline.Replace("out ", "");
                uline = uline.Replace("highp ", "");
                uline = uline.Replace(";", "");
                uline = uline.Substring(uline.IndexOf(" ")).Trim();

                if (uline.IndexOf("//") != -1)
                {
                    var parts = uline.Split('/');
                    var (name, bind) = (parts[0], parts[1]);

                    if (bind.IndexOf("tfb:") != -1)
                    {
                        name = name.Trim();
                        bind = bind.Replace("tfb:", "").Trim();
                        ast.Feedbacks.Add((name, bind));
                    }
                }
            }

            if (!string.IsNullOrEmpty(line))
            {
                if (ast.Reading == "vertex")
                {
                    ast.VertexLines.Add(line);
                }
                else if (ast.Reading == "fragment")
                {
                    ast.FragmentLines.Add(line);
                }
            }

            line = readline();
            ast.LineOffset += 1;
        }
    }

    private static string PathToNamespace(string path, string basePath)
    {
        var parts = new Uri(Path.GetDirectoryName(basePath)).MakeRelativeUri(new Uri(path)).ToString().Split('/');

        return string.Join(".", parts.Take(parts.Length - 1));
    }

    private static string ToSnakeCase(string value) =>
        string.Join("_", Regex.Split(value, "(?<!^)(?:(?:(?<![A-Z])(?=[A-Z]))|(?:(?<![a-zA-Z])(?=[a-z])))")).ToUpper();

    public void Execute(GeneratorExecutionContext context)
    {
        var files  = new Dictionary<string, AdditionalText>();
        var scopes = new Dictionary<string, ImmutableHashSet<string>>();

        foreach (var file in context.AdditionalFiles)
        {
            if (Path.GetExtension(file.Path) == ".glsl")
            {
                files.Add(file.Path, file);
            }
            else if (Path.GetExtension(file.Path) == ".generate")
            {
                scopes.Add(Path.GetDirectoryName(file.Path), file.GetText()!.Lines.Select(x => x.ToString()).ToImmutableHashSet());
            }
        }

        var textInfo = new CultureInfo("en-us").TextInfo;

        if (!context.AnalyzerConfigOptions.GlobalOptions.TryGetValue("build_property.projectdir", out var projectDir))
        {
            projectDir = Path.GetFullPath(Path.Combine("Godot.Net", "Godot.Net.csproj"));
        }

        foreach (var item in files)
        {
            var file = item.Value;

            if (scopes.TryGetValue(Path.GetDirectoryName(file.Path), out var scope) && scope.Contains(Path.GetFileName(file.Path)))
            {
                var type = file.Path.Contains(Path.Combine("Drivers", "GLES3", "Shaders"))
                    ? "GLES3"
                    : file.Path.Contains(Path.Combine("Servers", "Rendering", "RendererRD", "Shaders"))
                        ? "RD"
                        : "RAW";

                var fileName   = Path.GetFileNameWithoutExtension(item.Value.Path);
                var className  = textInfo.ToTitleCase(fileName).Replace("_", "") + "Shader" + type;
                var @namespace = PathToNamespace(file.Path, projectDir);

                var source = type switch
                {
                    "GLES3" => GenerateGLES3(file, files, @namespace, className, type),
                    "RD" =>    GenerateRDGLES(file, files, @namespace, className, type),
                    _ =>       GenerateRaw(file, files, className),
                };

                context.AddSource(className + ".g.cs", source);
            }
        }
    }

    public void Initialize(GeneratorInitializationContext context)
    { }
}
